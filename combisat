#!/usr/bin/python

from __future__ import with_statement

import sys
import optparse
import threading
import subprocess
import shlex
import fcntl
import errno

from optparse import OptionParser
from StringIO import StringIO
from threading import Thread
from threading import Semaphore

# The number of assignments per "v" group in the DIMACS output
DIMACS_SOLUTION_WRAP = 10

def parseDIMACSHeader(inputFile):
    crtLine = inputFile.readline()
    crtLine = crtLine.strip() # Remove the surrounding whitespace
    
    lineTokens = crtLine.split(None, 1)
    assert len(lineTokens) == 2, "Invalid DIMACS header format"
    assert len(lineTokens[0]) == 1, "Invalid DIMACS header format"
    
    return (lineTokens[0], lineTokens[1])

def parseDIMACSFormula(inputFile):
    varCount = 0
    clauseCount = 0
    
    # Parsing the header
     
    while True:
        (hType, hContents) = parseDIMACSHeader(inputFile)
        
        if hType == "c":
            pass # Ignore the comments, for now
        elif hType == "p":
            formatTokens = hContents.split()
            assert len(formatTokens) == 3, "Invalid formula format specifications"
            assert formatTokens[0] == "cnf", "Invalid formula format - cnf is requested"
            
            varCount = int(formatTokens[1])
            clauseCount = int(formatTokens[2])
            
            break
        else:
            pass #Ignore any additional header
    
    # Read up until the end of the file, and parse the contents
    
    clauseText = inputFile.read()
    clauseTokens = clauseText.split()
    clauseData = [int(tok) for tok in clauseTokens]
    
    formula = CNFFormula(varCount)
    
    crtClause = []
    for elem in clauseData:
        if elem == 0:
            assert len(crtClause) > 0, "Only non-empty clauses allowed"
            
            formula.clauses.append(crtClause)
            crtClause = []
        else:
            negate = False
            if elem < 0:
                negate = True
                elem = -elem
            
            assert elem <= varCount, "Gaps in the variable numbering not allowed"
            
            crtClause.append((elem, negate))
            
    assert len(crtClause) == 0, "Unterminated clause encountered"
    assert len(formula.clauses) == clauseCount, "Clause count inconsistency"
    
    return formula

def parseDIMACSSolution(inputFile):
    solution = []
    while True:
        (hType, hContents) = parseDIMACSHeader(inputFile)
        
        if hType == "s":
            if hContents == "UNSATISFIABLE":
                assert len(solution) == 0, "Inconsistent results"
                return solution
            
            assert hContents == "SATISFIABLE", "Invalid satisfiability solution"
            
        elif hType == "v":
            dataValues = [int(tok) for tok in hContents.split()]
            
            for x in dataValues:
                if x == 0:
                    return solution
                elif x > 0:
                    solution.append((x, False))
                else:
                    solution.append((-x, True))
        else:
            pass # Just ignore
    
    

def emitDIMACSFormula(outputFile, formula, comments=None):
    if comments is not None:
        for comment in comments:
            outputFile.write("c %s\n" % comment)
            
    outputFile.write("p cnf %d %d\n" % (formula.varCount, len(formula.clauses)) )
    
    for clause in formula.clauses:
        for lit in clause:
            value = lit[0]
            if lit[1]:
                value = -value
                
            outputFile.write("%d " % value)
        
        outputFile.write("0\n")
        
def emitDIMACSSolution(outputFile, solution):
    if len(solution) == 0:
        outputFile.write("s UNSATISFIABLE\n")
        return
    
    outputFile.write("s SATISFIABLE\n")
    
    wrapCounter = 0
    
    for elem in solution:
        value = elem[0]
        if elem[1]:
            value = -value
            
        if wrapCounter == 0:
            outputFile.write("v ")
        
        outputFile.write("%d " % value)
        
        wrapCounter = (wrapCounter + 1) % DIMACS_SOLUTION_WRAP
        
        if wrapCounter == 0:
            outputFile.write("\n")
            
    if wrapCounter == 0:
        outputFile.write("v ")
    
    outputFile.write("0\n")
        
def getDIMACSFormula(formula, comments=None):
    strFile = StringIO()
    emitDIMACSFormula(strFile, formula, comments)
    dimacsFormula = strFile.getvalue()
    strFile.close()
    
    return dimacsFormula

class CNFFormula:
    """The representation of a SAT formula in conjunctive normal form"""
    def __init__(self, varCount = 0):
        self.clauses = []
        self.varCount = varCount
        
class SATSolver:
    """The base class for a generic solver"""
    def __init__(self):
        pass
    
    def solve(self, formula):
        pass
    
    def abort(self):
        pass
    
class ExternalSolver(SATSolver):
    def __init__(self, path):
        self.path = path
        
        args = shlex.split(self.path)
        self.proc = subprocess.Popen(args,
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE,
                                     close_fds=True)
        
    def solve(self, formula):
        # Compose the formula to send
        dimacsFormula = getDIMACSFormula(formula)
        
        try:
            (outdata, errdata) = self.proc.communicate(dimacsFormula)
        except OSError as error:
            if error.errno == errno.EPIPE:
                pass
            else:
                raise
        
        if self.proc.returncode >= 0 and len(outdata) > 0:
            solFile = StringIO(outdata)
            solution = parseDIMACSSolution(solFile)
            return solution
        
    def abort(self):
        try:
            self.proc.kill()
        except OSError as error:
            if error.errno == errno.ESRCH:
                pass
            else:
                raise
            
class _PortfolioThread(Thread):
    def __init__(self, solver, formula, sem):
        Thread.__init__(self)
        
        self.solution = None
        self.solver = solver
        self.formula = formula
        self.sem = sem
        
    def run(self):
        self.solution = self.solver.solve(self.formula)
        self.sem.release()
    
class PortfolioSolver(SATSolver):
    """A strategy portfolio SAT solver"""
    def __init__(self, solvers):
        self.solvers = solvers
        
    def solve(self, formula):   
        solverThreads = []
        solution = None
        
        sem = Semaphore(0)
        
        for solver in self.solvers:
            sThread = _PortfolioThread(solver, formula, sem)
            solverThreads.append(sThread)
            
            sThread.start()
        
        # Wait for at least one thread to finish
        sem.acquire()
            
        for sThread in solverThreads:
            if solution is None:
                if sThread.solution is not None:
                    solution = sThread.solution
            
            sThread.solver.abort()
                
        assert solution is not None, "Solver returned with invalid solution"
                
        for sThread in solverThreads:
            sThread.join()
            
        return solution
            
    def abort(self):
        pass

def main():
    # Read the command line arguments
    parser = OptionParser()
    parser.add_option("-s", "--solver", action="append", dest="solver_paths")
    
    (options, args) = parser.parse_args()
    
    if len(args) != 1:
        parser.print_usage(sys.stderr)
        exit(1)
        
    if options.solver_paths is None:
        sys.stderr.write("You need to specify at least one solver.\n")
        exit(1)
        
    formula = None
        
    with open(args[0]) as inputFile:
        formula = parseDIMACSFormula(inputFile)
        
    solvers = []
    
    for path in options.solver_paths:
        solvers.append(ExternalSolver(path))
        
    portfolio = PortfolioSolver(solvers)
    
    solution = portfolio.solve(formula)
    
    emitDIMACSSolution(sys.stdout, solution)


if __name__ == "__main__":
    main()
    
